// mindelay.co
// A Comet program to solve cumulative scheduling problems from CuSPLIB.
// It reads CuSPLIB files in the raw format generated by geninst.pl.
// Author: Tallys Yunes

import cotfd;

// Read command-line parameters

int nargs = System.argc();
string [] args = System.getArgs();
string filename = " ";

forall (i in 2..nargs) {
  if (args[i-1].prefix(2).equals("-f"))
    filename = args[i-1].suffix(2);
}

ifstream datafile(filename);

if (! datafile.good()) {
  cout << "Can't open input file " << filename << endl;
  cout << "Usage: comet cumul.co -f<data file>" << endl;
  System.exit(0);
}

// Read data from input file

int N = datafile.getInt();
int T = datafile.getInt();
int Cap = datafile.getInt();

range Jobs = 1..N;

int P[Jobs];  // processing time
int R[Jobs];  // release date
int D[Jobs];  // due date
int C[Jobs];  // resource consumption
int W[Jobs];  // weight

forall (j in Jobs) {
  P[j] = datafile.getInt();
  R[j] = datafile.getInt();
  D[j] = datafile.getInt();
  C[j] = datafile.getInt();
  W[j] = datafile.getInt();
}

// Upper bound on objective function value
int maxObj = sum (j in Jobs) W[j]*D[j];

Scheduler<CP> cp(T);

// Declare the variables

Activity<CP> act[j in Jobs](cp,P[j]);
DiscreteResource<CP> machine(cp,Cap);
var<CP>{int} objective(cp,0..maxObj);

cp.limitTime(3600);

int t0 = System.getCPUTime();

minimize<cp> objective
subject to {
  forall (j in Jobs) {
    act[j].requires(machine,C[j]);
    cp.post( act[j].start() >= R[j] );
    cp.post( act[j].end() <= D[j] );
  }

  cp.post( objective == sum (j in Jobs) W[j]*(act[j].start() - R[j]) );
}
using {

  setTimes(act);

  // Do a labelFF of activity start times. This is typically less
  // efficient than using the setTimes heuristic above.
  //forall (j in Jobs) by (act[j].start().getSize())
  //  tryall<cp> (v in act[j].start().getMin()..act[j].start().getMax() :
  //              act[j].start().memberOf(v)) cp.label(act[j].start(),v);

  cout << "objective: " << objective << endl;
  cout << "time: " << (System.getCPUTime() - t0)/1000 << " secs" << endl;
  cout << "fail: " << cp.getNFail() << endl << endl;
}

cout << "Total time: " << (System.getCPUTime() - t0)/1000 << " secs" << endl;
cout << "Total fail: " << cp.getNFail() << endl;

if (cp.getSolution() != null) {
  cout << "TotalDelay = " << objective << endl;
  cout << "Start times:" << endl;
  forall (j in Jobs)
    cout << "s[" << j << "] = " << act[j].start() << endl;
}
else {
  cout << "No solution found." << endl;
}
